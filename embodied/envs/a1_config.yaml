a1:
  env:
    num_envs: 8
    num_actions: 12
    env_spacing: 3.  # not used with heightfields/trimeshes 
    episode_length_s: 4 # episode length in seconds

  terrain:
    mesh_type: 'trimesh' # "heightfield" # none, plane, heightfield or trimesh
    horizontal_scale: 0.1 # [m]
    vertical_scale: 0.005 # [m]
    border_size: 25 # [m]
    curriculum: True
    static_friction: 1.0
    dynamic_friction: 1.0
    restitution: 0.
    # rough terrain only:
    measure_heights: True
    measured_points_x: [-0.8, -0.7, -0.6, -0.5, -0.4, -0.3, -0.2, -0.1, 0., 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8] # 1mx1.6m rectangle (without center line)
    measured_points_y: [-0.5, -0.4, -0.3, -0.2, -0.1, 0., 0.1, 0.2, 0.3, 0.4, 0.5]
    selected: False # select a unique terrain type and pass all arguments
    terrain_kwargs: null # Dict of arguments for selected terrain
    max_init_terrain_level: 5 # starting curriculum state
    terrain_length: 8.
    terrain_width: 8.
    num_rows: 10 # number of terrain rows (levels)
    num_cols: 20 # number of terrain cols (types)
    # terrain types: [smooth slope, rough slope, stairs up, stairs down, discrete]
    terrain_proportions: [0.1, 0.1, 0.35, 0.25, 0.2]
    # trimesh only:
    slope_treshold: 0.75 # slopes above this threshold will be corrected to vertical surfaces

  commands:
    curriculum: False
    max_curriculum: 1.
    num_commands: 4 # default: lin_vel_x, lin_vel_y, ang_vel_yaw, heading (in heading mode ang_vel_yaw is recomputed from heading error)
    resampling_time: 10. # time before command are changed[s]
    heading_command: True # if true: compute ang vel command from heading error

    ranges: {lin_vel_x: [-1.0, 1.0], lin_vel_y: [-1.0, 1.0], ang_vel_yaw: [-1, 1], heading: [-3.14, 3.14]}

  init_state:
    pos: [0.0, 0.0, 0.42] # x,y,z [m]
    rot: [0.0, 0.0, 0.0, 1.0] # x,y,z,w [quat]
    lin_vel: [0.0, 0.0, 0.0]  # x,y,z [m/s]
    ang_vel: [0.0, 0.0, 0.0]  # x,y,z [rad/s]
    default_joint_angles: { # = target angles [rad] when action = 0.0
        FL_hip_joint: 0.1,   # [rad]
        RL_hip_joint: 0.1,   # [rad]
        FR_hip_joint: -0.1 ,  # [rad]
        RR_hip_joint: -0.1,   # [rad]

        FL_thigh_joint: 0.8,     # [rad]
        RL_thigh_joint: 1.,   # [rad]
        FR_thigh_joint: 0.8,     # [rad]
        RR_thigh_joint: 1.,   # [rad]

        FL_calf_joint: -1.5,   # [rad]
        RL_calf_joint: -1.5,    # [rad]
        FR_calf_joint: -1.5,  # [rad]
        RR_calf_joint: -1.5,    # [rad]
    }

  control:
    control_type: 'P' # P: position, V: velocity, T: torques
    # PD Drive parameters:
    stiffness: {joint: 20.}  # [N*m/rad]
    damping: {joint: 0.5}     # [N*m*s/rad]
    # decimation: Number of control action updates @ sim DT per policy DT
    decimation: 4

  asset:
    file: '{ASSET_PATH}/a1/urdf/a1.urdf'
    name: "a1"  # actor name
    foot_name: "foot" # name of the feet bodies, used to index body state and contact force tensors
    penalize_contacts_on: ["thigh", "calf"]
    terminate_after_contacts_on: ["base"]
    disable_gravity: False
    collapse_fixed_joints: True # merge bodies connected by fixed joints. Specific fixed joints can be kept by adding " <... dont_collapse="true">
    fix_base_link: False # fixe the base of the robot
    default_dof_drive_mode: 3 # see GymDofDriveModeFlags (0 is none, 1 is pos tgt, 2 is vel tgt, 3 effort)
    self_collisions: 1 # 1 to disable, 0 to enable...bitwise filter
    replace_cylinder_with_capsule: True # replace collision cylinders with capsules, leads to faster/more stable simulation
    flip_visual_attachments: True # Some .obj meshes must be flipped from y-up to z-up
    
    density: 0.001
    angular_damping: 0.
    linear_damping: 0.
    max_angular_velocity: 1000.
    max_linear_velocity: 1000.
    armature: 0.
    thickness: 0.01

  domain_rand:
    randomize_friction: True
    friction_range: [0.5, 1.25]
    randomize_base_mass: False
    added_mass_range: [-1., 1.]
    push_robots: True
    push_interval_s: 15
    max_push_vel_xy: 1.

  rewards:
    scales:
      dof_pos_limits: -10.0
      termination: -0.0
      tracking_lin_vel: 1.0
      tracking_ang_vel: 0.5
      lin_vel_z: 0. # -2.0
      ang_vel_xy: 0. # -0.05
      orientation: -0.
      torques: 0. # -0.0002
      dof_vel: -0.
      dof_acc: 0. # -2.5e-7
      base_height: -0. 
      feet_air_time:  0. # 1.0
      collision: 0. # -1.
      feet_stumble: -0.0 
      action_rate: 0. # -0.01
      stand_still: -0.

    only_positive_rewards: True # if true negative total rewards are clipped at zero (avoids early termination problems)
    tracking_sigma: 0.25 # tracking reward: exp(-error^2/sigma)
    soft_dof_pos_limit: 0.9 # percentage of urdf limits, values above this limit are penalized
    soft_dof_vel_limit: 1.
    soft_torque_limit: 1.
    base_height_target: 0.25
    max_contact_force: 100. # forces above this value are penalized

  normalization:
    obs_scales:
      lin_vel: 2.0
      ang_vel: 0.25
      dof_pos: 1.0
      dof_vel: 0.05
      height_measurements: 5.0
    clip_observations: 100.
    clip_actions: 100.

  noise:
    add_noise: True
    noise_level: 1.0 # scales other values
    noise_scales:
      dof_pos: 0.01
      dof_vel: 1.5
      lin_vel: 0.1
      ang_vel: 0.2
      gravity: 0.05
      height_measurements: 0.1

  # viewer camera:
  viewer:
    ref_env: 0
    pos: [10, 0, 6]  # [m]
    lookat: [11., 5., 3.]  # [m]

  sim:
    dt:  0.005
    substeps: 1
    gravity: [0., 0. ,-9.81]  # [m/s^2]
    up_axis: 1  # 0 is y, 1 is z

    physx:
      num_threads: 10
      solver_type: 1  # 0: pgs, 1: tgs
      num_position_iterations: 4
      num_velocity_iterations: 0
      contact_offset: 0.01  # [m]
      rest_offset: 0.0   # [m]
      bounce_threshold_velocity: 0.5 #0.5 [m/s]
      max_depenetration_velocity: 1.0
      max_gpu_contact_pairs: 8388608 #2**24 -> needed for 8000 envs and more
      default_buffer_size_multiplier: 5
      contact_collection: 2 # 0: never, 1: last sub-step, 2: all sub-steps (default=2)